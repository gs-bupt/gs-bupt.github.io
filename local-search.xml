<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>即时通讯</title>
    <link href="/2023/06/22/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/"/>
    <url>/2023/06/22/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>实现即时通讯常见的有四种方式，分别是：轮询、长轮询(comet)、长连接(SSE)、WebSocket。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>拉模式，不管服务端数据有无更新，客户端利用Ajex定时发送请求拉取一次数据，可能有更新数据返回，也可能什么都没有。<br><strong>优点</strong>: 后端编码简单<br><strong>缺点</strong>: 数据延迟、消耗资源过大、请求次数太多</p><img src="/2023/06/22/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/image.png" class="" title="轮询"><h3 id="长轮询-comet"><a href="#长轮询-comet" class="headerlink" title="长轮询(comet)"></a>长轮询(comet)</h3><p>客户端发起长轮询，如果服务端的数据没有发生变更，会hold住请求，直到服务端的数据发生变化，或者等待一定时间超时才会返回。返回后，客户端再发起下一次长轮询请求监听。<br><strong>优点</strong>:</p><ul><li>相较于轮询基本不存在消息延迟，请求次数降低很多</li><li>长轮询是在 XMLHttpRequest 之后实现的，它几乎得到了设备的普遍支持，因此通常很少需要有进一步的备选方案，在很多场景下，可以作为即时通信的最简单实现方案和兜底兼容方案。</li></ul><p><strong>缺点</strong>:服务器一直保持连接会消耗资源，需要同时维护多个线程，而服务器所能承载的 TCP 连接是有上限的，所以这种轮询很容易导致连接上限。</p><img src="/2023/06/22/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/image-2.png" class="" title="长轮询"><h3 id="长连接-SSE"><a href="#长连接-SSE" class="headerlink" title="长连接(SSE)"></a>长连接(SSE)</h3><p>客户端和服务端建立连接后不进行断开，之后客户端再次访问这个服务端上的内容时，继续使用这一条连接通道<br><strong>优点</strong>: 消息即时到达，不发无用请求<br><strong>缺点</strong>: 与长轮询一样，服务器一直保持连接是会消耗资源的，如果有大量的长连接的话，对于服务器的消耗是巨大的，而且服务器承受能力是有上限的，不可能维持无限个长连接。</p><img src="/2023/06/22/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/image-3.png" class="" title="SSE"><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>客户端向服务器发送一个携带特殊信息的请求头（Upgrade:WebSocket ）建立连接，建立连接后双方即可实现自由的实时双向通信。<br><strong>优点</strong>:</p><ul><li>较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。</li><li>更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。</li><li>保持连接状态。与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</li></ul><p><strong>缺点</strong>: 相对来说，开发成本和难度更高。例如，当连接终止时，WebSockets 无法自动恢复连接。</p><img src="/2023/06/22/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/image-4.png" class="" title="WebSocket"><h2 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h2><p>长轮询挂起请求，等待新数据更新后再响应的处理方式虽然能减少浏览器的请求次数，并带来即时性，但是如果使用同步处理请求的方式，挂起请求则代表了线程的阻塞，有多少长轮询请求未响应就代表要阻塞多少个Servlet线程。所以长轮询必须使用异步处理方式。</p><p>流程:</p><ul><li>请求发送到服务器。</li><li>服务器在有新数据之前不会响应请求。</li><li>当新数据出现、或超过预设等待时间时，服务器将对其请求作出响应。</li><li>浏览器立即发出一个新的请求。</li></ul><img src="/2023/06/22/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/image-5.png" class="" title="异步处理请求"><p>如上图，在主线程中开启异步处理，主线程将请求交给其他线程去处理，主线程就结束了，被放回了主线程池，由其他线程继续处理请求，可以避免主线程池线程耗尽，起到容器线池程和工作线程池隔离的效果。</p><h2 id="案例描述"><a href="#案例描述" class="headerlink" title="案例描述"></a>案例描述</h2><p>用户在网页使用微信扫码登陆，使用手机app扫码后微信服务器向后端服务器回调扫码事件，由于前端无法感知到用户手机扫码的行为，所以停留在扫码登陆页面时需要持续轮询后端服务器用户是否已扫码登录，造成服务器的较大压力，于是利用Servlet3.0的异步特性，实现长轮询的方式来通信。</p><p>前端的扫码登录页面向后端请求微信登录二维码，后端返回微信登录二维码给前端时附带随机生成的scene_id，前端显示二维码供用户手机微信扫码，前端持续轮询后端用户是否已扫码（上一次轮询未成功登陆为开启下一次轮询的条件），但需带上scene_id以区分扫码用户，此时后端不同步返回前端请求结果，而是以异步响应式的方式等待微信服务器回调后，或是超过指定时间例如30秒后再返回（可能用户打开登陆页面后停留但未成功扫码），大大减少了前端访问后端的次数。</p>]]></content>
    
    
    <categories>
      
      <category>Web设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo+github</title>
    <link href="/2023/06/22/hexo-github/"/>
    <url>/2023/06/22/hexo-github/</url>
    
    <content type="html"><![CDATA[<h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h2><p>​Hexo是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h2 id="Hexo-结构"><a href="#Hexo-结构" class="headerlink" title="Hexo 结构"></a>Hexo 结构</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">.<br>├── _config.yml                     <br>├── package.json<br>├── public                   // 公共文件夹，这个文件夹用于存放生成的站点文件。<br>├── scaffolds                // 模板文件夹，存储page、draft、page的模板<br>├── source                   // 资源文件夹，这个文件夹用来存放内容。<br>|   ├── _drafts                     <br>|   └── _posts<br>└── themes<br></code></pre></td></tr></table></figure><h2 id="Hexo-写作"><a href="#Hexo-写作" class="headerlink" title="Hexo 写作"></a>Hexo 写作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new [layout] &lt;title&gt;  # 创建一篇新文章或者新页面<br></code></pre></td></tr></table></figure><p>layout: 文章的布局，通过_config.yml中的default_layout参数指定默认布局</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init<br>git add .<br>git commit -m &quot;first commit&quot;<br>git branch -M main<br>git remote <br>git <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
